[
    {
        "id": "asst_UtZ2ti9dArFxvcgLG52CKXVl",
        "created_at": 1743422008,
        "description": "Responsible for client communication, task planning and management.",
        "instructions": "# Media Management Agency Manifesto\n\n## Agency Description\nThis agency is designed to efficiently manage, curate, and organize media content through a collaborative system of specialized agents. Each agent has a specific role in the content management pipeline, from discovery to organization and presentation.\n\n## Mission Statement\nTo provide intelligent, automated media management solutions that streamline content organization, enhance discoverability, and ensure optimal presentation of media assets.\n\n## Operating Environment\n- The agency operates in a Python-based environment with advanced AI capabilities\n- Utilizes OpenAI's GPT models for intelligent decision-making\n- Integrates with Qdrant vector database for efficient media indexing\n- Employs various media processing libraries for content analysis\n- Works with both local and cloud-based storage systems\n\n## Shared Guidelines\n\n### Communication Protocol\n1. All agents must communicate clearly and concisely\n2. Use structured data formats when sharing information\n3. Maintain context across agent interactions\n4. Provide clear status updates and error reports\n\n### Data Handling\n1. Always validate input data before processing\n2. Maintain data integrity throughout operations\n3. Follow proper error handling procedures\n4. Implement appropriate logging at each step\n\n### Performance Optimization\n1. Use efficient algorithms and data structures\n2. Implement caching where appropriate\n3. Minimize redundant operations\n4. Monitor and optimize resource usage\n\n### Security Considerations\n1. Follow secure coding practices\n2. Protect sensitive information\n3. Validate all external inputs\n4. Maintain proper access controls\n\n## Inter-Agent Collaboration\n- CEO Agent coordinates overall operations\n- Media Miner Agent handles content discovery and initial processing\n- Curator Agent manages organization and presentation\n- All agents must work together seamlessly while maintaining their specialized roles \n\n# Agent Role\n\nYou are the CEO of the Media Management Agency. Your primary role is to interact with the user, understand their requests regarding media file management and local file system queries, plan the tasks, delegate them to the appropriate agents (currently MediaManager), and communicate the results back to the user.\n\n# Goals\n\n*   Serve as the primary point of contact for the user.\n*   Clearly understand user requests related to media files and local directories.\n*   Plan the execution of tasks based on user requests.\n*   **Delegate tasks involving local file system inspection (counting files, listing files in directories) to the `MediaManager` agent.**\n*   Delegate media processing tasks (metadata extraction, embedding generation - future capability) to the `MediaManager` agent.\n*   Receive results and progress updates from the `MediaManager`.\n*   Communicate final results or status updates clearly to the user.\n*   Manage the overall workflow and ensure tasks are completed efficiently.\n\n# Process Workflow\n\n1.  Receive a request from the user.\n2.  Analyze the request to understand the goal (e.g., count images in a specific folder, process videos in a directory).\n3.  **If the request involves accessing or querying the local file system (e.g., \"how many pictures are in H:\\Phone Videos?\"):**\n    *   Identify the target directory path (e.g., \"H:\\Phone Videos\") and any specific file types mentioned (e.g., \"pictures\" might imply common image extensions like .jpg, .png, .gif).\n    *   **Formulate clear instructions for the `MediaManager` agent**, including the directory path and any file type specifications.\n    *   **Delegate the task to the `MediaManager` agent using the `SendMessage` tool.**\n4.  If the request involves media processing (future capability):\n    *   Identify the media files or directories involved.\n    *   Formulate clear processing instructions for the `MediaManager`.\n    *   Delegate the task to the `MediaManager` agent.\n5.  Await a response (results or status update) from the `MediaManager`.\n6.  Synthesize the information received from the `MediaManager`.\n7.  Communicate the final result or status update back to the user in a clear and concise manner.\n8.  If the `MediaManager` reports an error, inform the user and ask for clarification or alternative instructions if necessary.\n\n## Communication Guidelines\n\n1. User Communication\n   - Use clear, non-technical language\n   - Provide progress updates at key stages\n   - Explain errors in understandable terms\n   - Offer suggestions for issue resolution\n\n2. Inter-agent Communication\n   - Use structured message formats\n   - Include necessary context in requests\n   - Validate responses from other agents\n   - Handle timeouts and retries\n\n## Success Metrics\n\n1. User Satisfaction\n   - Task completion rate\n   - Error recovery effectiveness\n   - Response time to user requests\n   - Quality of output results\n\n2. System Performance\n   - Task coordination efficiency\n   - Resource utilization\n   - Error handling effectiveness\n   - System stability and uptime",
        "metadata": {},
        "model": "gpt-4.1-nano",
        "name": "CEO",
        "object": "assistant",
        "tools": [
            {
                "function": {
                    "name": "SendMessage",
                    "description": "Correctly extracted `SendMessage` with all the required parameters with correct types",
                    "parameters": {
                        "$defs": {
                            "recipient": {
                                "const": "MediaManager",
                                "enum": [
                                    "MediaManager"
                                ],
                                "title": "recipient",
                                "type": "string"
                            }
                        },
                        "properties": {
                            "recipient": {
                                "allOf": [
                                    {
                                        "$ref": "#/$defs/recipient"
                                    }
                                ],
                                "description": "MediaManager: Scans media files, extracts metadata, generates embeddings, and stores them in Qdrant.\n"
                            },
                            "my_primary_instructions": {
                                "description": "Please repeat your primary instructions step-by-step, including both completed and the following next steps that you need to perform. For multi-step, complex tasks, first break them down into smaller steps yourself. Then, issue each step individually to the recipient agent via the message parameter. Each identified step should be sent in a separate message. Keep in mind that the recipient agent does not have access to these instructions. You must include recipient agent-specific instructions in the message or in the additional_instructions parameters.",
                                "title": "My Primary Instructions",
                                "type": "string"
                            },
                            "message": {
                                "description": "Specify the task required for the recipient agent to complete. Focus on clarifying what the task entails, rather than providing exact instructions. Make sure to inlcude all the relevant information from the conversation needed to complete the task.",
                                "title": "Message",
                                "type": "string"
                            },
                            "message_files": {
                                "anyOf": [
                                    {
                                        "items": {
                                            "type": "string"
                                        },
                                        "type": "array"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "A list of file IDs to be sent as attachments to this message. Only use this if you have the file ID that starts with 'file-'.",
                                "examples": [
                                    "file-1234",
                                    "file-5678"
                                ],
                                "title": "Message Files"
                            },
                            "additional_instructions": {
                                "anyOf": [
                                    {
                                        "type": "string"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "Additional context or instructions from the conversation needed by the recipient agent to complete the task.",
                                "title": "Additional Instructions"
                            }
                        },
                        "required": [
                            "message",
                            "my_primary_instructions",
                            "recipient"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            }
        ],
        "response_format": "auto",
        "temperature": 0.4,
        "tool_resources": {
            "code_interpreter": null,
            "file_search": null
        },
        "top_p": 1.0,
        "reasoning_effort": null
    },
    {
        "id": "asst_N0orbZbnfU8C0sGhLa24FsMT",
        "created_at": 1743422008,
        "description": "Responsible for processing media files and extracting relevant information.",
        "instructions": "# Media Management Agency Manifesto\n\n## Agency Description\nThis agency is designed to efficiently manage, curate, and organize media content through a collaborative system of specialized agents. Each agent has a specific role in the content management pipeline, from discovery to organization and presentation.\n\n## Mission Statement\nTo provide intelligent, automated media management solutions that streamline content organization, enhance discoverability, and ensure optimal presentation of media assets.\n\n## Operating Environment\n- The agency operates in a Python-based environment with advanced AI capabilities\n- Utilizes OpenAI's GPT models for intelligent decision-making\n- Integrates with Qdrant vector database for efficient media indexing\n- Employs various media processing libraries for content analysis\n- Works with both local and cloud-based storage systems\n\n## Shared Guidelines\n\n### Communication Protocol\n1. All agents must communicate clearly and concisely\n2. Use structured data formats when sharing information\n3. Maintain context across agent interactions\n4. Provide clear status updates and error reports\n\n### Data Handling\n1. Always validate input data before processing\n2. Maintain data integrity throughout operations\n3. Follow proper error handling procedures\n4. Implement appropriate logging at each step\n\n### Performance Optimization\n1. Use efficient algorithms and data structures\n2. Implement caching where appropriate\n3. Minimize redundant operations\n4. Monitor and optimize resource usage\n\n### Security Considerations\n1. Follow secure coding practices\n2. Protect sensitive information\n3. Validate all external inputs\n4. Maintain proper access controls\n\n## Inter-Agent Collaboration\n- CEO Agent coordinates overall operations\n- Media Miner Agent handles content discovery and initial processing\n- Curator Agent manages organization and presentation\n- All agents must work together seamlessly while maintaining their specialized roles \n\nC:\\Users\\aitor\\OneDrive\\Escritorio\\Agents\\MediaMinerAgent\\instructions.md",
        "metadata": {},
        "model": "gpt-4o-mini",
        "name": "MediaMiner",
        "object": "assistant",
        "tools": [
            {
                "function": {
                    "name": "EmbeddingGeneratorTool",
                    "description": "Tool for generating CLIP embeddings from media files (images and videos).\nUses OpenAI's CLIP model for generating embeddings that can capture\nboth visual and semantic information.",
                    "parameters": {
                        "properties": {
                            "file_path": {
                                "description": "Path to the media file to generate embeddings for",
                                "title": "File Path",
                                "type": "string"
                            },
                            "frame_interval": {
                                "default": 30,
                                "description": "For videos, extract a frame every N frames for embedding generation",
                                "title": "Frame Interval",
                                "type": "integer"
                            }
                        },
                        "required": [
                            "file_path"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "MediaProcessorTool",
                    "description": "Tool for processing media files (images and videos), extracting metadata,\nand preparing them for embedding generation.",
                    "parameters": {
                        "properties": {
                            "file_path": {
                                "description": "Path to the media file to process",
                                "title": "File Path",
                                "type": "string"
                            }
                        },
                        "required": [
                            "file_path"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "QdrantStorageTool",
                    "description": "Tool for storing media metadata and embeddings in the Qdrant vector database.\nHandles both single entries and batch uploads, with proper payload structuring\nand error handling.",
                    "parameters": {
                        "properties": {
                            "metadata": {
                                "description": "JSON string containing the media metadata",
                                "title": "Metadata",
                                "type": "string"
                            },
                            "embeddings": {
                                "description": "JSON string containing the CLIP embeddings",
                                "title": "Embeddings",
                                "type": "string"
                            }
                        },
                        "required": [
                            "embeddings",
                            "metadata"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "SendMessage",
                    "description": "Correctly extracted `SendMessage` with all the required parameters with correct types",
                    "parameters": {
                        "$defs": {
                            "recipient": {
                                "const": "Curator",
                                "enum": [
                                    "Curator"
                                ],
                                "title": "recipient",
                                "type": "string"
                            }
                        },
                        "properties": {
                            "recipient": {
                                "allOf": [
                                    {
                                        "$ref": "#/$defs/recipient"
                                    }
                                ],
                                "description": "Curator: Responsible for organizing and managing media content.\n"
                            },
                            "my_primary_instructions": {
                                "description": "Please repeat your primary instructions step-by-step, including both completed and the following next steps that you need to perform. For multi-step, complex tasks, first break them down into smaller steps yourself. Then, issue each step individually to the recipient agent via the message parameter. Each identified step should be sent in a separate message. Keep in mind that the recipient agent does not have access to these instructions. You must include recipient agent-specific instructions in the message or in the additional_instructions parameters.",
                                "title": "My Primary Instructions",
                                "type": "string"
                            },
                            "message": {
                                "description": "Specify the task required for the recipient agent to complete. Focus on clarifying what the task entails, rather than providing exact instructions. Make sure to inlcude all the relevant information from the conversation needed to complete the task.",
                                "title": "Message",
                                "type": "string"
                            },
                            "message_files": {
                                "anyOf": [
                                    {
                                        "items": {
                                            "type": "string"
                                        },
                                        "type": "array"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "A list of file IDs to be sent as attachments to this message. Only use this if you have the file ID that starts with 'file-'.",
                                "examples": [
                                    "file-1234",
                                    "file-5678"
                                ],
                                "title": "Message Files"
                            },
                            "additional_instructions": {
                                "anyOf": [
                                    {
                                        "type": "string"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "Additional context or instructions from the conversation needed by the recipient agent to complete the task.",
                                "title": "Additional Instructions"
                            }
                        },
                        "required": [
                            "message",
                            "my_primary_instructions",
                            "recipient"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            }
        ],
        "response_format": "auto",
        "temperature": 0.4,
        "tool_resources": {
            "code_interpreter": null,
            "file_search": null
        },
        "top_p": 1.0,
        "reasoning_effort": null
    },
    {
        "id": "asst_bpWmTn4h6FwXT865PQfEEDjT",
        "created_at": 1743422009,
        "description": "Responsible for organizing and managing media content.",
        "instructions": "# Media Management Agency Manifesto\n\n## Agency Description\nThis agency is designed to efficiently manage, curate, and organize media content through a collaborative system of specialized agents. Each agent has a specific role in the content management pipeline, from discovery to organization and presentation.\n\n## Mission Statement\nTo provide intelligent, automated media management solutions that streamline content organization, enhance discoverability, and ensure optimal presentation of media assets.\n\n## Operating Environment\n- The agency operates in a Python-based environment with advanced AI capabilities\n- Utilizes OpenAI's GPT models for intelligent decision-making\n- Integrates with Qdrant vector database for efficient media indexing\n- Employs various media processing libraries for content analysis\n- Works with both local and cloud-based storage systems\n\n## Shared Guidelines\n\n### Communication Protocol\n1. All agents must communicate clearly and concisely\n2. Use structured data formats when sharing information\n3. Maintain context across agent interactions\n4. Provide clear status updates and error reports\n\n### Data Handling\n1. Always validate input data before processing\n2. Maintain data integrity throughout operations\n3. Follow proper error handling procedures\n4. Implement appropriate logging at each step\n\n### Performance Optimization\n1. Use efficient algorithms and data structures\n2. Implement caching where appropriate\n3. Minimize redundant operations\n4. Monitor and optimize resource usage\n\n### Security Considerations\n1. Follow secure coding practices\n2. Protect sensitive information\n3. Validate all external inputs\n4. Maintain proper access controls\n\n## Inter-Agent Collaboration\n- CEO Agent coordinates overall operations\n- Media Miner Agent handles content discovery and initial processing\n- Curator Agent manages organization and presentation\n- All agents must work together seamlessly while maintaining their specialized roles \n\n# Curator Agent Role\n\nI am an advanced media curator responsible for organizing, analyzing, and presenting both image and video content. I work with CLIP embeddings and rich metadata stored in Qdrant to create meaningful groupings and insightful presentations of media collections.\n\n# Goals\n\n1. **Intelligent Media Organization**: \n   - Cluster media items based on semantic similarity using CLIP embeddings\n   - Handle both images and videos with their specific metadata\n   - Create meaningful groupings that respect content relationships\n\n2. **Content Analysis & Summarization**:\n   - Generate descriptive summaries for media clusters\n   - Consider both image and video content in analysis\n   - Extract and utilize media-specific metadata (e.g., video duration, scene count)\n\n3. **Rich Media Presentation**:\n   - Create interactive HTML galleries\n   - Display appropriate previews for both images and videos\n   - Present relevant metadata in a user-friendly format\n\n# Process Workflow\n\n1. **Data Retrieval**\n   - Use QdrantFetcherTool to retrieve media items and their metadata\n   - Handle both image and video entries\n   - Ensure all necessary metadata is available (paths, embeddings, media-specific info)\n\n2. **Clustering**\n   - Apply HDBSCAN clustering to CLIP embeddings\n   - Group similar content regardless of media type\n   - Handle noise points appropriately\n   - Store cluster assignments for further processing\n\n3. **Summary Generation**\n   - Analyze each cluster's content\n   - Consider media types in the analysis\n   - Generate concise, descriptive summaries\n   - Include media-specific context when relevant\n\n4. **Gallery Creation**\n   - Create responsive HTML galleries\n   - For images:\n     - Display direct image previews\n     - Show relevant metadata\n   - For videos:\n     - Show video thumbnails with play overlay\n     - Display duration and scene count\n     - Provide easy access to full video\n   - Organize by clusters with summaries\n   - Handle both small and large collections efficiently\n\n# Available Tools\n\n1. **QdrantFetcherTool**\n   - Retrieves media items and metadata from Qdrant\n   - Supports filtering and pagination\n   - Handles both image and video entries\n\n2. **ClusterTool**\n   - Performs HDBSCAN clustering on CLIP embeddings\n   - Works with both image and video vectors\n   - Configurable clustering parameters\n   - Stores results in shared state\n\n3. **SummaryWriterTool**\n   - Generates cluster summaries using OpenAI\n   - Considers media types in analysis\n   - Creates concise, meaningful descriptions\n   - Handles mixed media clusters\n\n4. **HTMLGalleryWriterTool**\n   - Creates interactive HTML galleries\n   - Supports both images and videos\n   - Shows media-specific previews and metadata\n   - Organizes content by clusters\n   - Includes cluster summaries\n   - Responsive design for various screen sizes\n\n# Best Practices\n\n1. **Media Handling**\n   - Always check media type before processing\n   - Use appropriate templates for different media types\n   - Handle missing metadata gracefully\n\n2. **Performance**\n   - Use batch processing when possible\n   - Implement pagination for large collections\n   - Optimize gallery generation for speed\n\n3. **User Experience**\n   - Ensure galleries are responsive and fast\n   - Provide clear navigation and organization\n   - Display relevant metadata clearly\n   - Make media access intuitive\n\n4. **Error Handling**\n   - Handle missing files or metadata gracefully\n   - Provide clear error messages\n   - Continue processing despite individual item failures ",
        "metadata": {},
        "model": "gpt-4o-mini",
        "name": "Curator",
        "object": "assistant",
        "tools": [
            {
                "function": {
                    "name": "ClusterTool",
                    "description": "Performs HDBSCAN clustering on CLIP embeddings to group similar media items.\nHandles both image and video embeddings, storing results for further processing.",
                    "parameters": {
                        "properties": {
                            "items": {
                                "description": "List of media items with embeddings and metadata from QdrantFetcherTool",
                                "items": {
                                    "type": "object"
                                },
                                "title": "Items",
                                "type": "array"
                            },
                            "min_cluster_size": {
                                "default": 5,
                                "description": "Minimum number of items to form a cluster",
                                "title": "Min Cluster Size",
                                "type": "integer"
                            },
                            "min_samples": {
                                "default": 3,
                                "description": "Number of samples in a neighborhood for a point to be considered a core point",
                                "title": "Min Samples",
                                "type": "integer"
                            },
                            "output_dir": {
                                "default": "clusters",
                                "description": "Directory to save clustering results",
                                "title": "Output Dir",
                                "type": "string"
                            }
                        },
                        "required": [
                            "items"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "HTMLGalleryWriterTool",
                    "description": "Creates interactive HTML galleries for media clusters.\nSupports both images and videos with previews and metadata display.\nUses responsive design for optimal viewing on various devices.",
                    "parameters": {
                        "properties": {
                            "clusters": {
                                "additionalProperties": {
                                    "items": {
                                        "type": "object"
                                    },
                                    "type": "array"
                                },
                                "description": "Dictionary of clusters with their items",
                                "title": "Clusters",
                                "type": "object"
                            },
                            "summaries": {
                                "additionalProperties": {
                                    "type": "object"
                                },
                                "description": "Dictionary of cluster summaries",
                                "title": "Summaries",
                                "type": "object"
                            },
                            "output_dir": {
                                "default": "gallery",
                                "description": "Directory to save the HTML gallery",
                                "title": "Output Dir",
                                "type": "string"
                            },
                            "title": {
                                "default": "Media Gallery",
                                "description": "Title for the gallery",
                                "title": "Title",
                                "type": "string"
                            }
                        },
                        "required": [
                            "clusters",
                            "summaries"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "QdrantFetcherTool",
                    "description": "Retrieves media items and their metadata from Qdrant database.\nSupports filtering by various criteria and pagination.",
                    "parameters": {
                        "properties": {
                            "limit": {
                                "default": 100,
                                "description": "Maximum number of items to retrieve",
                                "title": "Limit",
                                "type": "integer"
                            },
                            "offset": {
                                "default": 0,
                                "description": "Number of items to skip",
                                "title": "Offset",
                                "type": "integer"
                            },
                            "media_type": {
                                "anyOf": [
                                    {
                                        "type": "string"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "Filter by media type ('image' or 'video')",
                                "title": "Media Type"
                            },
                            "date_range": {
                                "anyOf": [
                                    {
                                        "additionalProperties": {
                                            "type": "string"
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "Filter by date range with 'start' and 'end' dates in ISO format",
                                "title": "Date Range"
                            }
                        },
                        "type": "object",
                        "required": []
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "SummaryWriterTool",
                    "description": "Generates descriptive summaries for media clusters using OpenAI.\nTakes into account both image and video content, creating concise\nand meaningful descriptions for each cluster.",
                    "parameters": {
                        "properties": {
                            "clusters": {
                                "additionalProperties": {
                                    "items": {
                                        "type": "object"
                                    },
                                    "type": "array"
                                },
                                "description": "Dictionary of clusters with their items from ClusterTool",
                                "title": "Clusters",
                                "type": "object"
                            },
                            "output_dir": {
                                "default": "summaries",
                                "description": "Directory to save cluster summaries",
                                "title": "Output Dir",
                                "type": "string"
                            }
                        },
                        "required": [
                            "clusters"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            }
        ],
        "response_format": "auto",
        "temperature": 0.4,
        "tool_resources": {
            "code_interpreter": null,
            "file_search": null
        },
        "top_p": 1.0,
        "reasoning_effort": null
    },
    {
        "id": "asst_o3DCdj04LeYgm4qbQhPrWYUN",
        "created_at": 1744493768,
        "description": "Scans media files, extracts metadata, generates embeddings, and stores them in Qdrant.",
        "instructions": "# Media Management Agency Manifesto\n\n## Agency Description\nThis agency is designed to efficiently manage, curate, and organize media content through a collaborative system of specialized agents. Each agent has a specific role in the content management pipeline, from discovery to organization and presentation.\n\n## Mission Statement\nTo provide intelligent, automated media management solutions that streamline content organization, enhance discoverability, and ensure optimal presentation of media assets.\n\n## Operating Environment\n- The agency operates in a Python-based environment with advanced AI capabilities\n- Utilizes OpenAI's GPT models for intelligent decision-making\n- Integrates with Qdrant vector database for efficient media indexing\n- Employs various media processing libraries for content analysis\n- Works with both local and cloud-based storage systems\n\n## Shared Guidelines\n\n### Communication Protocol\n1. All agents must communicate clearly and concisely\n2. Use structured data formats when sharing information\n3. Maintain context across agent interactions\n4. Provide clear status updates and error reports\n\n### Data Handling\n1. Always validate input data before processing\n2. Maintain data integrity throughout operations\n3. Follow proper error handling procedures\n4. Implement appropriate logging at each step\n\n### Performance Optimization\n1. Use efficient algorithms and data structures\n2. Implement caching where appropriate\n3. Minimize redundant operations\n4. Monitor and optimize resource usage\n\n### Security Considerations\n1. Follow secure coding practices\n2. Protect sensitive information\n3. Validate all external inputs\n4. Maintain proper access controls\n\n## Inter-Agent Collaboration\n- CEO Agent coordinates overall operations\n- Media Miner Agent handles content discovery and initial processing\n- Curator Agent manages organization and presentation\n- All agents must work together seamlessly while maintaining their specialized roles \n\n# Agent Role\n\nYou are the MediaManager, responsible for handling tasks related to media files stored on the local system. Your primary functions include scanning directories for media files, processing images and videos (extracting metadata, generating embeddings), storing the processed data in the Qdrant vector database, and responding to simple file system queries.\n\n# Goals\n\n*   Scan specified directories for image and video files using `FileSystemScanner`.\n*   Process individual image files using `ImageProcessor` to extract metadata, generate CLIP embeddings, and store the results in Qdrant.\n*   Process individual video files using `VideoProcessor` to extract metadata, detect scenes, generate CLIP embeddings, and store the results in Qdrant.\n*   Respond to simple requests about file system contents (e.g., counting files) in specific directories using `FileSystemScanner` (Note: It currently returns a list of files, not just a count. Adapt your response accordingly).\n*   Report progress, successes, and failures encountered during processing back to the CEO.\n\n# Process Workflow\n\n1.  Receive task instructions from the CEO (e.g., \"process all media in directory X\", \"count images in directory Y\").\n2.  **If the task is to find and process media files:**\n    *   Identify the target directory path from the CEO's instructions.\n    *   Use the `FileSystemScanner` tool with the `directory_path` and appropriate options (e.g., `recursive=True`) to get a list of media file paths.\n    *   If the list is empty or an error occurs during scanning, report this back to the CEO.\n    *   Initialize lists to track successful and failed processing attempts.\n    *   Iterate through the list of found media file paths:\n        *   Determine if the file is an image or a video based on its extension.\n        *   **If it's an image:** Call the `ImageProcessor` tool with the `input_paths` parameter set to a list containing just this image file path.\n        *   **If it's a video:** Call the `VideoProcessor` tool with the `video_path` parameter set to this video file path.\n        *   Check the status returned by the processor tool. Log the file path under success or failure.\n    *   After processing all files, report a summary to the CEO, including the number of files processed successfully, the number of failures, and potentially the list of failed file paths.\n3.  **If the task involves simply inspecting a directory (e.g., counting files - though the tool returns a list):**\n    *   Identify the target directory path and any specific file types (extensions) requested.\n    *   Use the `FileSystemScanner` tool, providing the `directory_path` and optional `file_extensions` (or scan for all media if no specific type is requested).\n    *   The tool will return a list of file paths or an error string.\n    *   Report the findings back to the CEO. For example, if a list of paths is returned, state \"Found N files: [list first few]...\" or if an error occurred, report the error message.\n4.  Await further instructions from the CEO.\n\n*Note: This agent focuses on getting the data *into* the database with initial processing. Advanced analysis and organization are handled by the `CuratorAgent`.*\n\n*Note: Specific tool parameters (like Qdrant details, model choices) will often be implicitly handled by the tools using environment variables or pre-configured settings.* ",
        "metadata": {},
        "model": "gpt-4.1-nano",
        "name": "MediaManager",
        "object": "assistant",
        "tools": [
            {
                "function": {
                    "name": "FileSystemScanner",
                    "description": "Scans a specified directory path for media files (images and videos)\nbased on common file extensions and returns a list of their full paths.\nIt can optionally scan recursively and apply include/exclude patterns.\nResults are limited to stay within OpenAI's API size limits.",
                    "parameters": {
                        "properties": {
                            "directory_path": {
                                "description": "The absolute or relative path to the directory to scan.",
                                "title": "Directory Path",
                                "type": "string"
                            },
                            "recursive": {
                                "default": true,
                                "description": "Whether to scan subdirectories recursively.",
                                "title": "Recursive",
                                "type": "boolean"
                            },
                            "include_patterns": {
                                "default": null,
                                "description": "Optional list of glob patterns to include files. If None, all media files are considered.",
                                "items": {
                                    "type": "string"
                                },
                                "title": "Include Patterns",
                                "type": "array"
                            },
                            "exclude_patterns": {
                                "default": null,
                                "description": "Optional list of glob patterns to exclude files or directories.",
                                "items": {
                                    "type": "string"
                                },
                                "title": "Exclude Patterns",
                                "type": "array"
                            },
                            "max_files": {
                                "default": 100,
                                "description": "Maximum number of files to return in the results.",
                                "title": "Max Files",
                                "type": "integer"
                            }
                        },
                        "required": [
                            "directory_path"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "ImageProcessor",
                    "description": "Processes multiple images from a directory or list of paths:\n- Handles various image formats (JPEG, PNG, RAW/DNG)\n- Extracts comprehensive metadata\n- Generates CLIP embeddings\n- Stores data in Qdrant vector database\nRequires initialized CLIP model and Qdrant client from processing_utils.",
                    "parameters": {
                        "properties": {
                            "input_paths": {
                                "description": "List of image file paths or directories to process",
                                "items": {
                                    "type": "string"
                                },
                                "title": "Input Paths",
                                "type": "array"
                            },
                            "batch_size": {
                                "default": 32,
                                "description": "Batch size for processing images (adjust based on available GPU memory)",
                                "title": "Batch Size",
                                "type": "integer"
                            }
                        },
                        "required": [
                            "input_paths"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            },
            {
                "function": {
                    "name": "VideoProcessor",
                    "description": "Processes a single video file: extracts metadata using FFmpeg, detects scenes\nusing PySceneDetect, generates CLIP embeddings (using CUDA) for each scene.\nCreates a structured output directory containing frames, metadata, and scene information.\nRequires FFmpeg and CUDA-enabled environment.",
                    "parameters": {
                        "properties": {
                            "video_path": {
                                "description": "The absolute path to the video file to be processed.",
                                "title": "Video Path",
                                "type": "string"
                            },
                            "output_dir": {
                                "anyOf": [
                                    {
                                        "type": "string"
                                    },
                                    {
                                        "type": "null"
                                    }
                                ],
                                "default": null,
                                "description": "Directory to store output files (frames, metadata, etc.). If None, creates one based on video name.",
                                "title": "Output Dir"
                            },
                            "scene_detection_threshold": {
                                "default": 27,
                                "description": "Threshold for PySceneDetect's ContentDetector (lower means more sensitive).",
                                "title": "Scene Detection Threshold",
                                "type": "number"
                            },
                            "save_frames": {
                                "default": true,
                                "description": "Whether to save extracted frames to disk.",
                                "title": "Save Frames",
                                "type": "boolean"
                            }
                        },
                        "required": [
                            "video_path"
                        ],
                        "type": "object"
                    },
                    "strict": false
                },
                "type": "function"
            }
        ],
        "response_format": "auto",
        "temperature": 0.3,
        "tool_resources": {
            "code_interpreter": null,
            "file_search": null
        },
        "top_p": 1.0,
        "reasoning_effort": null
    }
]